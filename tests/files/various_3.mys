class ReturnFoo:
    v: i32

    def bar(self) -> ReturnFoo:
        return ReturnFoo(2 * self.v)

@test
def test_return_foo():
    foo = ReturnFoo(1).bar().bar().bar()

    assert foo.v == 8

@test
def test_value_if_cond_else_value():
    assert (1 if True else 2) == 1

    a = 1
    b = 2
    c = 3

    assert (a if 1 == b else c) == c

def deduce_foo() -> (u16, [i64]):
    return (1, [3, 4])

@test
def test_deduce_compare_types():
    assert u8(1) == 1
    assert -5 != 1
    assert [i8(-1)] == [-1]
    assert (u8(1), 5) == (1, i8(5))
    assert deduce_foo() == (1, [3, 4])
    assert (1.0, [3, 4]) != (1.0, [3, -4, 4, 1])
    assert (1.0, [3, 4]) != (1.0, [3, i8(-4)])
    assert ([(1, True), (i8(5), False)]) == ([(1, True), (5, False)])
    assert [[(1, True)]] != [[(1, True)], [], []]
    assert ([], 5) == ([], 5)
    assert [] == []
    v: [i16] = []
    assert v == []
    assert [[]] == [[]]
    assert [[], []] != [[], [(True, False)]]

# ToDo
# class UserError(Error):
#
#     pass
#
# @test
# def test_user_defined_error():
#     res = 0
#
#     try:
#         raise UserError()
#     except UserError:
#         res = 1
#
#     assert res == 1

@test
def test_unary():
    assert -1 == -1
    assert -1.0 == -1.0
    assert +1 == +1
    assert +1.0 == +1.0

@test
def test_variable_declaration():
    values: [[i32]] = [[], []]
    assert values == [[], []]

@test
def test_define_variable_in_if_and_else_branches_1():
    y = 0

    if False:
        x = 1
        y = 2
    else:
        x = 3
        y = 4

    assert x == 3
    assert y == 4

@test
def test_define_variable_in_if_and_else_branches_2():
    if False:
        x = 1
    elif False:
        x = 2
    else:
        if True:
            x = 3
        else:
            x = 4

    assert x == 3

@test
def test_define_list_variable_in_if_and_else_branches():
    if True:
        x = [1, 3, 5]
    else:
        x = [2]

    assert x == [1, 3, 5]

@test
def test_define_variable_in_try_except_branches_1():
    try:
        x: i8 = 1
    except:
        x: i8 = 2

    assert x == 1

@test
def test_define_variable_in_try_except_branches_2():
    try:
        x = 3
    except GeneralError:
        x = 2
    except ValueError:
        x = 1

    assert x == 3

@test
def test_define_variable_in_try_except_branches_3():
    try:
        x = 3
    except GeneralError:
        x = 2
    else:
        pass

    assert x == 3

@test
def test_define_variable_in_try_except_branches_4():
    try:
        x = 3
    except GeneralError:
        x = 2
    else:
        x = 4

    assert x == 4

@test
def test_define_variable_in_all_branches_1():
    try:
        if False:
            x = 1
        else:
            x = 2
    except GeneralError:
        try:
            x = 3
        except:
            if True:
                x = 4
            else:
                x = 5

    assert x == 2

@test
def test_system_exit_error():
    try:
        res = 0

        raise SystemExitError()
    except SystemExitError:
        res = 1

    assert res == 1

def named_parameters(a: bool, b: string, c: string) -> string:
    return f"{a} {b} {c}"

@test
def test_named_function_parameters():
    assert named_parameters(True, "1", "2") == "True 1 2"
    assert named_parameters(a=True, b="1", c="2") == "True 1 2"
    assert named_parameters(True, c="1", b="2") == "True 2 1"
    assert named_parameters(True, "1", c="2") == "True 1 2"

@trait
class NamedBase:

    def named_parameters_base(self, a: bool, b: string, c: NamedFoo) -> string:
        return f"{a} {b} {c}"

class NamedFoo(NamedBase):

    def named_parameters(self, a: bool, b: string, c: string) -> string:
        return f"{a} {b} {c}"

def named_parameters_base(base: NamedBase):
    foo = NamedFoo()

    assert base.named_parameters_base(True, "1", foo) == "True 1 NamedFoo()"
    assert base.named_parameters_base(a=True, b="1", c=foo) == "True 1 NamedFoo()"
    assert base.named_parameters_base(True, c=foo, b="2") == "True 2 NamedFoo()"
    assert base.named_parameters_base(True, "1", c=foo) == "True 1 NamedFoo()"
    assert base.named_parameters_base(True, "1", c=None) == "True 1 None"

@test
def test_named_method_parameters():
    foo = NamedFoo()

    assert foo.named_parameters(True, "1", "2") == "True 1 2"
    assert foo.named_parameters(a=True, b="1", c="2") == "True 1 2"
    assert foo.named_parameters(True, c="1", b="2") == "True 2 1"
    assert foo.named_parameters(True, "1", c="2") == "True 1 2"

    named_parameters_base(foo)

class NamedDefaultFoo:
    a: i32
    b: i32
    c: string

    def __init__(self, a: i32, b: i32 = -1, c: string = None):
        self.a = a
        self.b = b
        self.c = c

@test
def test_constructor_with_named_and_default_parameters():
    foo = NamedDefaultFoo(1)
    assert foo.a == 1
    assert foo.b == -1
    assert foo.c is None

    foo = NamedDefaultFoo(1, b=-1)
    assert foo.a == 1
    assert foo.b == -1
    assert foo.c is None

    foo = NamedDefaultFoo(1, b=5, c="hi")
    assert foo.a == 1
    assert foo.b == 5
    assert foo.c  == "hi"

    foo = NamedDefaultFoo(1, c="hi", b=2)
    assert foo.a == 1
    assert foo.b == 2
    assert foo.c == "hi"

def return_tuple_items_as_none() -> (string, bytes, [bool], {bool: i32}):
    return (None, None, None, None)

@test
def test_return_tuple_items_as_none():
    assert return_tuple_items_as_none() is not (None, None, None, None)
    assert return_tuple_items_as_none() == (None, None, None, None)

def cpp_reserved(long: i32) -> i32:
    return long

class CppReserved:
    true: i32

@test
def test_cpp_reserved():
    short = 1
    assert short == 1

    default: i8 = 2
    assert default == 2

    if default == 1 or short == 2:
        pass

    for int in range(1):
        pass

    assert cpp_reserved(1) == 1
    assert CppReserved(1).true == 1

    if True:
        double = 1
    else:
        double = 2

    assert 1 == double

class ReturnSelf:

    def get_self(self) -> ReturnSelf:
        return self

    def get_same(self, this: ReturnSelf) -> ReturnSelf:
        return this

@test
def test_return_self():
    x = ReturnSelf()

    assert x is x.get_self()
    assert x is x.get_same(x)
    assert x is x.get_self().get_same(x)

@test
def test_negative_list_index():
    values = [0, 2, 4, 6]

    assert values[-1] == 6
    assert values[-2] == 4
    assert values[-4] == 0

    res = 0

    try:
        print(values[-5])
    except IndexError:
        res = 1

    assert res == 1

@test
def test_negative_string_index():
    values = "0246"

    assert values[-1] == '6'
    assert values[-2] == '4'
    assert values[-4] == '0'

    res = 0

    try:
        print(values[-5])
    except IndexError:
        res = 1

    assert res == 1

@test
def test_negative_bytes_index():
    values = b"\x00\x02\x04\x06"

    assert values[-1] == 6
    assert values[-2] == 4
    assert values[-4] == 0

    res = 0

    try:
        print(values[-5])
    except IndexError:
        res = 1

    assert res == 1

@test
def test_reuse_variable_tuple_unpack():
    a, b = ("1", False)
    assert a == "1"
    assert not b

    a, b = ("2", True)
    assert a == "2"
    assert b
