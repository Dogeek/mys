# pylint: disable=using-constant-test
# pylint: disable=undefined-variable

"""mys-embedded-c++-before-namespace
#if 0
#endif
"""

def foo() -> i32:
    return 5

V1: i32 = (1 << 2) / 2
V2: i32 = foo() + 1
V3: [u64] = [1, 1 + 1]
V4: [bool] = None
V5: i32 = V1

def bar(_a: (i32, string)):
    "A docstring."

# ToDo
# def fie(a: string) -> string:
#     return 2 * a

class Adder:

    value: i32
    base: i32

    def add(self, a: i32, b: i32) -> i32:
        "Docstring."

        return self.base + self.value + a + b

def calc(adder: Adder) -> i32:
    return adder.add(1, 4)

class OperatorOverloading:

    def __eq__(self, other: OperatorOverloading) -> bool:
        return True

    def __ne__(self, other: OperatorOverloading) -> bool:
        return True

    def __gt__(self, other: OperatorOverloading) -> bool:
        return True

    def __ge__(self, other: OperatorOverloading) -> bool:
        return True

    def __lt__(self, other: OperatorOverloading) -> bool:
        return True

    def __le__(self, other: OperatorOverloading) -> bool:
        return True

    def __iadd__(self, other: OperatorOverloading):
        pass

    def __isub__(self, other: OperatorOverloading):
        pass

@test
def test_1():
    # # Text.
    # with open("foo.txt", "w") as fout:
    #     fout.write("1")
    #
    # with open("foo.txt", "r") as fin:
    #     assert_eq(fin.read(), "1")
    #
    # # Binary.
    # with open("foo.bin", "wb") as fout:
    #     fout.write(b"\x01")
    #
    # with open("foo.bin", "rb") as fin:
    #     assert_eq(fin.read(), b"\x01")

    res = 0

    if True:
        res = 1

    assert res == 1

    if False:
        res = 2
    else:
        res = 3

    assert res == 3

    if False:
        res = 4
    elif False:
        res = 5
    elif True:
        res = 6
    else:
        res = 7

    assert res == 6

    try:
        raise TypeError("foo")
    except ValueError:
        res = 8
    except TypeError as e:
        # ToDo
        # print(e)
        res = 9
    finally:
        assert res == 9
        print("finally")
        res = 10

    assert res == 10

@test
def test_2():
    res = 0
    a = 5

    try:
        try:
            for i in range(5):
                print("i, a, i * a:", i, a, i * a)

            raise ValueError()
        except ValueError as e:
            res = 11
            # ToDo
            # print(e)
            raise

        raise TypeError()
    except ValueError as e:
        assert res == 11
        # ToDo
        # print(e)
        res = 12

    assert res == 12

    try:
        raise ValueError()
    except:
        res = 13
        print("Any")

    assert res == 13

    try:
        assert False
    except AssertionError as e:
        res = 14
        # ToDo
        # print(e)

    assert res == 14

    assert V1 == 2
    assert V2 == 6
    assert V3[0] == 1
    assert V3[1] == 2
    assert V4 is None
    assert V5 == (1 << 2) / 2

    adder = Adder(1, 0)
    assert adder.base == 0
    assert adder.value == 1
    adder.value += 1
    assert adder.value == 2
    assert str(adder) == "Adder(value=2, base=0)"
    # Print a class should work.
    print(adder)
    assert calc(adder) == 7

@test
def test_3():
    s = "hello"
    print("s:", s, len(s), str(s))
    assert len(s) == 5
    assert str(s) == s
    assert s == "hello"
    assert s != "hello!"
    t = s
    assert s == t
    t += "!"
    assert t == "hello!"
    assert s == t
    assert str(1) == "1"
    assert str(1.0) == "1.000000"
    u = -5000
    v = str(u)
    assert v == "-5000"
    # ToDo
    # assert_eq(4 * v, "-5000-5000-5000-5000")
    # assert_eq(v * 3, "-5000-5000-5000")
    assert v + v == "-5000-5000"

    # ToDo
    # assert fie(v) == "-5000-5000"

# ToDo: Uncomment.
@test
def test_4():
    w: [i32] = []
    print("w:", w)
    assert len(w) == 0
    w.append(5)
    w.append(1)
    print("w:", w)
    assert len(w) == 2
    x: [i32] = [5, 1, 5, 1]
    assert w != x
    # assert_eq(2 * w, x)
    # assert_eq(len(2 * w), 4)
    #
    l1: [i32] = [1, 2]
    acc = 0

    for i in l1:
        acc += i

    assert acc == 3

    res = 0

    try:
        res = 1
    finally:
        assert res == 1
        res = 2

    assert res == 2
    vv = 0

    """mys-embedded-c++

    vv = atoi("2");
    """

    assert vv == 2

    assert min(-10, 10) == -10
    assert min(-10, 10, -11) == -11
    assert min(100.1, -200.7) == -200.7
    assert max(-10, 10) == 10
    assert max(-10, 10, 11) == 11
    assert max(100.1, -200.7) == 100.1
    mm: i32 = 10
    nn: i32 = 15
    assert min(2 * mm, 21, nn) == 15
    assert max(2 * mm, 21, nn) == 21
    ll: [i32] = [mm, nn]
    assert min(ll) == 10
    assert max(ll) == 15
    # assert_eq(sum(ll), 25)
    assert abs(-1) == 1
    assert abs(5) == 5
    assert abs(-1.5) == 1.5

    s1 = """a\t
    multi
    line
    string\n"""
    s2 = "a\t\n    multi\n    line\n    string\n"
    assert s1 == s2

@test
def test_fstring():
    v: string = f""
    assert v == ""
    v = f"foo"
    assert v == "foo"
    assert f"c{1+1}s" == "c2s"
    # ToDo
    # assert_eq(f"{2 * v}", "foofoo")

@test
def test_list():
    v: [i32] = [3, 2, 1]
    assert v[0] == 3
    assert v[1] == 2
    assert v[2] == 1

    res = 0

    try:
        assert v[3] == 1
    except:
        res = 1

    assert res == 1

@test
def test_assert():
    value = False

    assert True
    assert 1 == i16(1)
    assert "a" == str("a")
    assert 1 == 1
    assert 1.0 == 1.0

    try:
        assert False
    except AssertionError:
        value = True

    assert value

@test
def test_assert_in():
    value = False
    values: [i32] = [1, 2, 4]
    assert 1 in values
    assert 2 in values
    assert 4 in values
    assert 1.0 in [1.0]
    assert "" in [""]

    try:
        assert 3 in values
    except AssertionError:
        value = True

    assert value

@test
def test_assert_not_in():
    value = False
    values: [i32] = [1, 2, 4]
    assert 0 not in values
    assert 3 not in values
    assert 5 not in values

    try:
        assert 1 not in values
    except AssertionError:
        value = True

    assert value

@test
def test_and_or():
    assert (True and False) == False
    assert True or False

@test
def test_not():
    assert not False
    assert not (not (False or True))

@test
def test_boolean_logic():
    assert (True and (not False) and False) == False
    assert (True and not False and False) == False
    assert True and (not False) or False
    assert (True and (not False)) or False
    assert True and ((not False) or False)

@test
def test_print():
    print("Hi!")
    print("Hi!", end="!!\n")
    print("Hi!", flush=True)

def default_1(a: i32 = 3) -> i32:
    return a

def default_2(a: i32 = 3, b: i32 = 2) -> i32:
    return a + b

def default_3(a: i32, b: i32 = 2) -> i32:
    return a + b

def default_4(a: i32, b: i32 = 2) -> i32:
    return a + b

# ToDo
# @test
# def test_default_params():
#     assert default_1() == 3
#     assert default_1(1) == 1
#     assert default_2() == 5
#     assert default_2(1) == 3
#     assert default_2(1, 0) == 1
#     # assert_eq(default_2(b=1), 4)
#     # assert_eq(default_2(b=1, a=0), 1)
#     # assert_eq(default_2(1, b=3), 4)
#     assert default_3(1) == 3
#     assert default_3(1, 0) == 1
#     # assert_eq(default_3(1, b=0), 1)
#     # assert_eq(default_3(a=1, b=0), 1)
#     # assert_eq(default_3(b=1, a=0), 1)

@test
def test_match_integer_1():
    value = 0
    res = 0

    match value:
        case 0:
            res = 1
        case _:
            res = 2

    assert res == 1

@test
def test_match_integer_2():
    value = 1

    match value:
        case 1:
            value = 3

    assert value == 3

@test
def test_match_string():
    value = "hi"
    res = 0

    match value:
        case "123":
            res = 5
        case "hi":
            res = 6
        case _:
            res = 7

    assert res == 6

@test
def test_match_bytes():
    value = b"hi"
    res = 0

    match value:
        case b"123":
            res = 5
        case b"hi":
            res = 6
        case _:
            res = 7

    assert res == 6

ONLY_ONCE_VALUE: i32 = 0

def only_once(value: i32) -> i32:
    ONLY_ONCE_VALUE += 1

    return value

@test
def test_match_function_once():
    value = 0
    ONLY_ONCE_VALUE = 0

    match only_once(1):
        case 0:
            value = 1
        case 1:
            value = 2

    assert value == 2
    assert ONLY_ONCE_VALUE == 1

@trait
class MatchBase:
    pass

class MatchFoo(MatchBase):
    pass

class MatchBar(MatchBase):
    pass

class MatchFie(MatchBase):
    pass

class MatchFum(MatchBase):
    pass

def foo_trait(base: MatchBase) -> i64:
    result = 0

    match base:
        case MatchFoo():
            result = 1
        case MatchBar() as value:
            result = 2
        case MatchFie() as value:
            result = 3
        case _:
            result = 4

    return result

@test
def test_match_trait():
    assert foo_trait(MatchFoo()) == 1
    assert foo_trait(MatchBar()) == 2
    assert foo_trait(MatchFie()) == 3
    assert foo_trait(MatchFum()) == 4

@test
def test_try_except_else():
    res = 0

    try:
        value = True
    except ValueError:
        res = 1
    else:
        # ToDo: 'value' is available
        # assert value
        res = 2

    assert res == 2

@test
def test_try_except_else_finally():
    """Same as previous test, but with finally.

    """

    res = 0

    try:
        value = True
    except ValueError:
        res = 1
    else:
        # ToDo: 'value' is available
        # assert value
        res = 2
    finally:
        res = 3

    assert res == 3

@trait
class Base:

    def bar(self, value: i32) -> bool:
        "A docstring."

@trait
class Base2:

    def fie(self):
        pass

class Foo(Base):

    def bar(self, value: i32) -> bool:
        return True

class Bar(Base, Base2):

    def bar(self, value: i32) -> bool:
        return False

    def fie(self):
        print()

def trait_call(base: Base) -> bool:
    return base.bar(1)

@test
def test_implement_trait_in_class():
    foo = Foo()
    bar = Bar()
    assert foo.bar(1)
    assert not bar.bar(1)
    assert trait_call(Foo())
    assert not trait_call(Bar())
    bar.fie()

class InferredFoo:

    a: i32

def inferred_foo() -> i32:
    return -3

@test
def test_inferred_types_in_assignments():
    value_1 = 1
    value_2 = -1
    value_3 = +1
    value_4 = "a"
    value_5 = True
    value_6 = 6.44
    value_7 = -6.44
    value_8 = InferredFoo(5)
    value_9 = inferred_foo()
    value_10 = InferredFoo(4).a

    assert value_1 == 1
    assert value_2 == -1
    assert value_3 == 1
    assert value_4 == "a"
    assert value_5 == True
    assert value_6 == 6.44
    assert value_7 == -6.44
    assert value_8.a == 5
    assert value_9 == -3
    assert_eq(value_10, 4)

@test
def test_not_inferred_types_in_assignments():
    value_1: i32 = 1
    value_2: i32 = -1
    value_3: i32 = +1
    value_4: string = "a"
    value_5: bool = True
    value_6: f64 = 6.44
    value_7: f64 = -6.44
    value_8: InferredFoo = InferredFoo(5)
    value_9: i32 = inferred_foo()
    value_10: i32 = InferredFoo(4).a

    assert value_1 == 1
    assert value_2 == -1
    assert value_3 == 1
    assert value_4 == "a"
    assert value_5 == True
    assert value_6 == 6.44
    assert value_7 == -6.44
    assert value_8.a == 5
    assert value_9 == -3
    assert value_10 == 4

@test
def test_inferred_type_list_item_access():
    res = 0
    numbers: [u64] = [1, 2, 3, 4, 5]
    needle = numbers[3]

    for value in numbers:
        if value == needle:
            res = 1
            break

    assert res == 1

def string_foo(value: string) -> string:
    value += " Mouse"

    return value

@test
def test_string_as_function_parameter():
    assert string_foo("Cat") == "Cat Mouse"

@enum
class City:

    Linkoping = 5
    Norrkoping = 8
    Vaxjo = 10

@test
def test_enum_if_else():
    value = City.Linkoping
    res = 0

    if value == City.Linkoping:
        res = 1
    elif value == City.Norrkoping:
        res = 2

    assert res == 1

@test
def test_enum_from_variable():
    value = 8

    assert City(value) == City.Norrkoping

@test
def test_enum_from_invalid_value():
    res = 1

    try:
        print(City(4))
        res = 2
    except ValueError:
        res = 3

    assert res == 3

def enum_foo(cites: [City]) -> bool:
    if cites[0] == City.Linkoping:
        return True
    else:
        return False

@test
def test_enum_list():
    values_1: [City] = [City.Linkoping]
    values_2: [City] = [City.Norrkoping, City.Linkoping]

    assert enum_foo(values_1)
    assert not enum_foo(values_2)

@test
def test_enum_assignment():
    value_1: City = City.Linkoping
    value_2 = City.Vaxjo

    assert value_1 == City.Linkoping
    assert value_2 == City.Vaxjo

def enum_bar(source: City, destination: City) -> City:
    return City.Vaxjo

@test
def test_enum_as_function_parameter_and_return_value():
    value = City.Linkoping

    assert enum_bar(value, City.Norrkoping) == City.Vaxjo

@test
def test_enum_match():
    res = 0
    value = City.Linkoping

    match value:
        case City.Norrkoping:
            res = 1
        case City.Linkoping:
            res = 2

    assert res == 2

class FooGlob:

    value: i32

def glob_foo(v: i32) -> i32:
    return 2 * v

def glob_bar(v: FooGlob) -> i32:
    return 3 * v.value

GLOB_1: i32 = 1
GLOB_2: string = ""
GLOB_3: FooGlob = FooGlob(5)
GLOB_4: i32 = glob_foo(1)
GLOB_5: i32 = glob_foo(glob_foo(-1))
GLOB_6: i32 = glob_foo(glob_bar(FooGlob(5)))
GLOB_7: i32 = GLOB_1
GLOB_8: [i64] = [1, 3]

@test
def test_global_variable():
    assert GLOB_1 == 1
    assert GLOB_2 == ""
    assert GLOB_3.value == 5
    assert GLOB_4 == 2
    assert GLOB_5 == -4
    assert GLOB_6 == 30
    assert GLOB_7 == 1
    assert GLOB_8[0] == 1
    assert GLOB_8[1] == 3

@test
def test_explicit_integer_type_convertions():
    v1: u8 = 0xff
    v2: i16 = -5

    assert v1 == u8(0x1ff)
    assert v2 == i16(-5)
    assert i32(i16(-1)) == i32(-1)
    assert u8(v2) == u8(0xfb)

@test
def test_integer_constants():
    v1 = 0x7fffffffffffffff
    v2: i64 = 0x7fffffffffffffff
    v3: i8 = 0x7f
    v4: i8 = -0x80
    v5: u8 = 0
    v6: u8 = 0xff
    v7: u64 = 0xffffffffffffffff

    assert v1 == v2
    assert v3 - 127 - 127 - 1 == v4
    assert v5 + 255 == v6
    assert v7 == 0xffffffffffffffff

@test
def test_change_integer_type():
    v1 = i8(-1) * i8(u32(5))

    assert v1 == -5

class TupleFoo:

    def foo(self) -> (bool, i64):
        return (True, -5)

@test
def test_tuple_unpack_method():
    foo = TupleFoo()
    a, b = foo.foo()

    assert a
    assert b == -5

def tuple_foo() -> (bool, i32, string):
    return (True, -5, "hi")

@test
def test_tuple_unpack_function():
    a, b, c = tuple_foo()

    assert a
    assert b == -5
    assert c == "hi"

@test
def test_iterate_over_list_of_integer_literals():
    res = 0

    for i in [5, 1]:
        res += i

    assert res == 6

@test
def test_iterate_over_list():
    res: u32 = 1
    values: [u32] = [3, 8]

    for value in values:
        res *= value

    assert res == 24

@test
def test_iterate_over_list_with_condition():
    res: u32 = 1
    values: [u64] = [3, 8, 1]

    for value in slice(values, 1):
        if value == 1:
            res = 2

    assert res == 2

@test
def test_iterate_over_list_of_strings():
    res = ""
    values: [string] = ["a", "b"]

    for value in values:
        res += value

    assert res == "ab"

@test
def test_iterate_over_range_1():
    res = 0

    for value in range(10):
        res += value

    assert res == 45

@test
def test_iterate_over_range_2():
    res = 0

    for value in range(9, 0, -2):
        res += value

    assert res == 25

def get() -> (string, string):
    return "Hello", "!"

@test
def test_strings():
    foo, bar = get()

    # Another reference to the same object.
    foo2 = foo
    foo += bar
    assert foo == "Hello!"
    assert foo2 == foo

@test
def test_tuple_init():
    foo, bar = 1, "b"

    assert foo == 1
    assert bar == "b"

@test
def test_tuple():
    foo = (1, "b")

    assert foo[0] == 1
    assert foo[1] == "b"

    foo[0] = 2
    foo[1] = "c"

    assert foo[0] == 2
    assert foo[1] == "c"

    foo = (3, "d")

    assert foo[0] == 3
    assert foo[1] == "d"

    foo[1], foo[0] = ("e", 4)

    assert foo[0] == 4
    assert foo[1] == "e"

    a: i64 = 0
    a, b = (1, True)

    assert a == 1
    assert b

@test
def test_iterate_over_enumerate_1():
    values: [u32] = [3, 8, 1]
    i_acc = 0
    value_acc = 0

    for i, value in enumerate(values):
        i_acc += i
        value_acc += value

    assert i_acc == 3
    assert value_acc == 12

@test
def test_iterate_over_enumerate_2():
    i_acc = 0
    value_acc = 0

    for i, value in enumerate([3, 8, 1]):
        i_acc += i
        value_acc += value

    assert i_acc == 3
    assert value_acc == 12

@test
def test_iterate_over_enumerate_3():
    i_acc = 0
    value_acc = 0

    for i, value in enumerate(range(5), 1):
        i_acc += i
        value_acc += value

    assert i_acc == 15
    assert value_acc == 10

@test
def test_iterate_over_enumerate_4():
    i_acc = 0
    value_acc = 0
    x = 5
    y = 1

    for i, value in enumerate(range(x), y):
        i_acc += i
        value_acc += value

    assert i_acc == 15
    assert value_acc == 10

@test
def test_iterate_over_enumerate_negative_initial():
    acc = 0

    for i, value in enumerate(range(5), -5):
        acc += i

    assert acc == -15

@test
def test_iterate_over_nested_enumerates():
    ij_acc = 0
    values_acc = 0

    for i, value_1 in enumerate([3, 8, 1]):
        ij_acc += i
        values_acc += value_1

        for j, value_2 in enumerate([-1, 3]):
            ij_acc += j
            values_acc += value_2

    assert ij_acc == (0 + 1 + 2) + 3 * (0 + 1)
    assert values_acc == (3 + 8 + 1) + 3 * (-1 + 3)

@test
def test_iterate_over_zip():
    acc = 0

    for x, y in zip(range(5), [3, 8, 1, 4, -2]):
        acc += x
        acc += y

    assert acc == 24

@test
def test_iterate_over_three_zip():
    acc = 0

    for x, y, z in zip(range(2), [3, 8], range(1, 3)):
        acc += x
        acc += y
        acc += z

    assert acc == 15

@test
def test_iterate_over_zip_mixed_types():
    s = ""
    acc = 0

    for x, y in zip(["a", "b"], range(1, 3)):
        s += x
        acc += y

    assert s == "ab"
    assert acc == 3

@test
def test_iterate_over_slice_1():
    acc = 0

    for x in slice(range(4), 2):
        acc += x

    assert acc == 5

@test
def test_iterate_over_slice_2():
    acc = 0
    s = ""

    for x, y in zip(slice(range(4), 2), ["a", "b"]):
        acc += x
        s += y

    assert acc == 5
    assert s == "ab"

@test
def test_iterate_over_slice_3():
    acc = 0

    for x in slice(range(10), 2, 4):
        acc += x

    assert acc == 5

@test
def test_iterate_over_slice_4():
    acc = 0

    for x in slice(range(10), 2, 5, 2):
        acc += x

    assert acc == 6

@test
def test_iterate_over_slice_5():
    acc = 0

    for x in slice(range(10), 2, -5, 2):
        acc += x

    assert acc == 6

@test
def test_iterate_over_slice_6():
    acc = 0

    for x in slice(range(10), -3, -1):
        acc += x

    assert acc == 15

@test
def test_iterate_over_slice_7():
    acc = 0

    for x in slice(range(10), 0, 10, -1):
        acc += x

    assert acc == 0

@test
def test_iterate_over_slice_8():
    acc = 0

    for x in slice(range(10), 1, 2, -1):
        acc += x

    assert acc == 0

@test
def test_iterate_over_slice_9():
    res = 0

    try:
        for x in slice(range(10), 0, 10, 0):
            res = 1
    except ValueError:
        res = 2

    assert res == 2

@test
def test_iterate_over_slice_10():
    acc = 0

    for x in slice(range(10), 10, 12):
        acc += x

    assert acc == 0

@test
def test_iterate_over_slice_11():
    acc = 0

    for x in slice(range(10), -12, -10):
        acc += x

    assert acc == 0

@test
def test_iterate_over_slice_12():
    s = ""

    for x in slice(["a", "b", "c", "d"], 2, 0, -1):
        s += x

    assert s == "cb"

@test
def test_iterate_over_slice_13():
    s = ""

    for x in slice(["a", "b", "c", "d"], -4, -3):
        s += x

    assert s == "a"

@test
def test_iterate_over_slice_14():
    s = ""

    for x in slice(["a", "b", "c", "d"], 0, 1):
        s += x

    assert s == "a"

@test
def test_iterate_over_slice_15():
    s = ""

    for x in slice(["a", "b", "c", "d"], -10, 1):
        s += x

    assert s == "a"

@test
def test_iterate_over_slice_16():
    s = ""

    for x in slice(["a", "b", "c", "d"], 3, 10):
        s += x

    assert s == "d"

@test
def test_iterate_over_slice_17():
    s = ""

    for x in slice(["a", "b", "c", "d"], 4, 10):
        s += x

    assert s == ""

@test
def test_iterate_over_slice_18():
    acc = 0
    s = ""

    for i, x in slice(enumerate(["a", "b", "c", "d"]), -3, -2):
        acc = i
        s = x

    assert acc == 1
    assert s == "b"

@test
def test_iterate_over_slice_19():
    s = ""

    for x in slice(["a", "b", "c", "d"], 5):
        s += x

    assert s == ""

@test
def test_iterate_over_slice_20():
    s = ""

    for x in slice(["a", "b", "c", "d"], -5):
        s += x

    assert s == "abcd"

@test
def test_iterate_over_slice_21():
    s = ""

    for x in slice(["a", "b", "c", "d"], 3, -1, -1):
        s += x

    assert s == ""

@test
def test_iterate_over_slice_22():
    s = ""

    for x in slice(["a", "b", "c", "d"], 3, -2, -1):
        s += x

    assert s == "d"

@test
def test_iterate_over_slice_23():
    s = ""

    for x in slice(["a", "b", "c", "d"], 2, -1, -1):
        s += x

    assert s == ""

@test
def test_iterate_over_slice_24():
    s = ""

    for x in slice(slice(["a", "b", "c", "d"], 1), 1):
        s += x

    assert s == "cd"

@test
def test_iterate_over_reversed_1():
    s = ""

    for x in reversed(["a", "b", "c", "d"]):
        s += x

    assert s == "dcba"

@test
def test_iterate_over_reversed_2():
    s = ""

    for x in reversed(slice(["a", "b", "c", "d"], 3, 1, -1)):
        s += x

    assert s == "cd"

@test
def test_iterate_over_reversed_3():
    s = ""

    for x in reversed(slice(["a", "b", "c", "d"], 3, 0, -2)):
        s += x

    assert s == "bd"

@test
def test_iterate_over_reversed_4():
    s = ""

    for x in reversed(slice(["a", "b", "c", "d"], 0, 3, 2)):
        s += x

    assert s == "ca"

@test
def test_iterate_over_reversed_5():
    s = ""

    for x in reversed(slice(range(4), 0, 3, 2)):
        s += str(x)

    assert s == "20"

@test
def test_iterate_over_reversed_6():
    s1 = ""
    s2 = ""

    for i, x in reversed(slice(enumerate(range(4), 5), 0, 3, 2)):
        s1 += str(i)
        s2 += str(x)

    assert s1 == "75"
    assert s2 == "20"

@test
def test_iterate_over_zip_not_same_lengths_1():
    res = 0

    try:
        for i, j in zip(range(1), range(2)):
            print(i, j)

        res = 1
    except ValueError:
        res = 2

    assert res == 2

@test
def test_iterate_over_zip_not_same_lengths_2():
    res = 0

    try:
        for i, j, k in zip(range(2), range(2), [1, 2, 3]):
            print(i, j, k)

        res = 1
    except ValueError:
        res = 2

    assert res == 2

@test
def test_iterate_over_zip_not_same_lengths_3():
    res = 0

    for i, (j, k) in enumerate(zip(range(2), range(2))):
        res += i
        res += j
        res += k

    assert res == 3

@test
def test_iterate_over_zip_not_same_lengths_4():
    res: [i64] = []

    for (i, j), k in zip(enumerate(range(2)), slice(range(4), 2)):
        res.append(i)
        res.append(j)
        res.append(k)

    assert res[0] == 0
    assert res[1] == 0
    assert res[2] == 2
    assert res[3] == 1
    assert res[4] == 1
    assert res[5] == 3

@test
def test_return_none():
    return

def foo_list(values: [i64]) -> i64:
    return values[0]

@test
def test_function_parameter_list():
    values = [5, 6]

    assert foo_list(values) == 5

@test
def test_assert_list_is_not_none():
    assert [1, 3] is not None

@test
def test_assert_none_is_not_string():
    assert None is not [0]

@test
def test_list_is_not_none():
    res = 0

    if [1, 3] is not None:
        res = 1

    assert res == 1

@test
def test_none_is_not_string():
    res = 0

    if None is not [0]:
        res = 1

    assert res == 1

@test
def test_none_is_none():
    res = 0

    if None is None:
        res = 1

    assert res == 1

@test
def test_list_as_none():
    value: [bool] = None

    assert value is None

class MembersFoo:

    pass

class Members:

    a: MembersFoo
    b: [i32]
    c: string
    d: u64
    e: (bool, string)

@test
def test_class_member_values():
    a = MembersFoo()
    b: [i32] = []
    members = Members(a, b, "hi", 1, (False, "ho"))
    assert members.a is a
    assert members.a is not None
    assert members.b is b
    assert members.b is not None
    assert members.c == "hi"
    assert members.d == 1
    assert not members.e[0]
    assert members.e[1] == "ho"

class PrivateMembers:

    _a: MembersFoo
    _b: [i32]
    _c: string
    _d: u64
    _e: (bool, string)
    _f: bool
    _g: char

    def get_a(self) -> MembersFoo:
        return self._a

    def get_b(self) -> [i32]:
        return self._b

    def get_c(self) -> string:
        return self._c

    def get_d(self) -> u64:
        return self._d

    def get_e(self) -> (bool, string):
        return self._e

    def get_f(self) -> bool:
        return self._f

    def get_g(self) -> char:
        return self._g

@test
def test_class_private_member_default_zero_values():
    members = PrivateMembers()
    assert members.get_a() is None
    assert members.get_b() is None
    assert members.get_c() is None
    assert members.get_d() == 0
    assert members.get_e() is None
    assert not members.get_f()
    assert members.get_g() == ''

class FooInit:

    a: [i64]
    b: string
    c: u64

    def __init__(self, a: [i64] = [5, 6]):
        self.a = a
        self.b = "hi"
        self.c = 99

@test
def test_foo_init_2():
    foo = FooInit(None)

    assert foo.a is None
    assert foo.b == "hi"
    foo.c = 99

def bar_list_1(values: [i32]) -> i32:
    res: i32 = 0

    for value in values:
        res += value

    return res

@test
def test_inferred_integer_list_type_1():
    assert bar_list_1([1, -5]) == -4

def bar_list_2(v: [i64]) -> [i64]:
    return v

@test
def test_inferred_integer_list_type_2():
    assert bar_list_2([]) == []
    assert bar_list_2([1, -5]) == [1, -5]

    if bar_list_2([1, -5]) != [1, -5]:
        assert False

@test
def test_len():
    assert len("123") == 3

class NestedFoo:

    value: i32

class NestedBar:

    foo: NestedFoo

@test
def test_link():
    bar = NestedBar(NestedFoo(-5))

    assert bar.foo.value == -5

class PrivateMember:
    _a: i32

    def _bar(self):
        self._a += 1

    def foo(self) -> i32:
        self._bar()

        return self._a

@test
def test_private_member():
    pm = PrivateMember()
    assert pm.foo() == 1

class PublicAndPrivateMembers:
    a: i32
    _b: bool
    _c: string

    def get_b(self) -> bool:
        return self._b

    def get_c(self) -> string:
        return self._c

@test
def test_public_and_private_members():
    assert PublicAndPrivateMembers(10).a == 10
    assert not PublicAndPrivateMembers(10).get_b()
    assert PublicAndPrivateMembers(10).get_c() is None

@test
def test_dict_1():
    a = {1: 2, 3: 4}

    assert 1 in a
    assert 2 not in a
    assert a[1] == 2
    assert a[3] == 4
    assert a.get(1, -1) == 2
    assert a.get(2, -1) == -1

    a[1] = 5
    assert a[1] == 5

    # ToDo
    # res = 0
    #
    # try:
    #     print(a[4])
    #     res = 1
    # except KeyError:
    #     res = 2
    #
    # assert res == 2

@test
def test_dict_2():
    a: {i64: i64} = {}
    assert len(a) == 0
    a[-1] = 1
    assert len(a) == 1

@test
def test_dict_3():
    a: {u8: bool} = {5: False}
    assert not a[5]
    assert a.get(4, True)

class DictFoo:

    v: i32

@test
def test_dict_4():
    a: {i64: DictFoo} = {}
    assert len(a) == 0

    a[0] = DictFoo(10)
    a[1] = DictFoo(5)
    assert a[0].v == 10
    assert a[1].v == 5

    b = a[0]
    assert b.v == 10

def dict_foo(v: {i64: bool}) -> {i64: bool}:
    v[5] = True

    return v

@test
def test_dict_5():
    a: {i64: bool} = {}
    b = dict_foo(a)
    assert 5 in a
    assert 5 in b
    assert a is b
    c: {i64: bool} = {}
    assert a is not c

@test
def test_dict_string_value():
    a: {i64: string} = {}
    a[-1] = "erik"
    a[-1] += " m"
    assert a[-1] == "erik m"

@test
def test_dict_string_key():
    a: {string: bool} = {"d": False}
    a["a"] = True
    a["b"] = False
    a["c"] = True
    assert a["a"]
    assert not a["b"]
    assert a["c"]
    assert "d" in a

@test
def test_dict_keys():
    d = {"a": 1, "b": 2}
    keys = d.keys()
    assert keys in [["a", "b"], ["b", "a"]]

@test
def test_dict_values():
    d = {"a": 1, "b": 2}
    values = d.values()
    assert values in [[1, 2], [2, 1]]

def foo_return_list() -> [u8]:
    return [1, 5]

@test
def test_return_list():
    values = foo_return_list()
    assert values[0] == 1
    assert values[1] == 5

@test
def test_str_tuple():
    assert str(("a", 1)) == "(a, 1)"

@test
def test_str_list():
    assert str([1, -2, 5]) == "[1, -2, 5]"

@test
def test_str_dict():
    assert str({1: 4}) == "{1: 4}"

@test
def test_str_bool():
    assert str(True) == "True"
    assert str(False) == "False"

@test
def test_str_asserts():
    a = "1"
    b = "1"
    assert a is a
    assert a is not b
    assert None is not a
    assert b is not None

@test
def test_str_compare():
    a = "1"
    b = "1"

    if not (a is a):
        assert False

    if not (a is not b):
        assert False

    if not (None is not a):
        assert False

    if not (b is not None):
        assert False

    if "" is None:
        assert False

    if a != b:
        assert False

@test
def test_list_index_out_of_range():
    v = [1, 2]
    raised = False

    try:
        print(v[2])
    except IndexError:
        raised = True

    assert raised

class AccessFoo:
    member: bool

    def func(self):
        pass

@test
def test_class_none_1():
    foo: AccessFoo = None
    res = 0

    assert foo is None

    try:
        print(foo.member)
    except NoneError:
        res = 1

    assert res == 1

    try:
        foo.func()
    except NoneError:
        res = 2

    assert res == 2

@test
def test_class_none_2():
    foo: AccessFoo = None
    foo2 = foo

    assert foo2 is foo

    foo = AccessFoo(True)

    assert foo is not foo2
    assert foo2 is None
    assert foo.member

@test
def test_string_none():
    v: string = None
    res = 0

    assert v is None

    try:
        v += "1"
    except NoneError:
        res = 1

    assert res == 1

@test
def test_float_literal():
    v = 1.0
    assert v == 1.0

    v = 1.0 + 2.0
    assert v == 1.0 + 2.0
    assert 3.0 == 1.0 + 2.0

    values = [1.0, 2.0]
    assert values == [1.0, 2.0]

@test
def test_list_from_dict():
    values = list({1: "a", 2: "b"})

    assert len(values) == 2
    assert (1, "a") in values
    assert (2, "b") in values

    # ToDo: Make "for k, v in values:" work.
    for pair in values:
        assert pair[0] in [1, 2]
        assert pair[1] in ["a", "b"]

@trait
class TraitStr:
    pass

class TraitFoo(TraitStr):
    a: i32

class TraitBar(TraitStr):
    b: string

def trait_str(v: TraitStr) -> string:
    return str(v)

@test
def test_trait_str():
    assert trait_str(TraitFoo(5)) == "TraitFoo(a=5)"
    assert trait_str(TraitBar("Kalle")) == "TraitBar(b=Kalle)"

@test
def test_compare_lists_1():
    assert [1] == [1]

    if [1] == [1]:
        pass
    else:
        assert False

    if [1] != [1]:
        assert False

    res = 0

    try:
        assert [1] == [2]
    except AssertionError:
        res = 1

    assert res == 1

@test
def test_compare_lists_2():
    res = 0

    if [1] is [1]:
        assert False

    try:
        assert [1] is [1]
    except AssertionError:
        res = 1

    assert res == 1

    assert [3] is not None

    if [3] is not None:
        pass
    else:
        assert False

@test
def test_compare_lists_3():
    values: [bool] = None
    res = 0

    try:
        if values == [True]:
            pass
    except NoneError:
        res = 1

    assert res == 1

@test
def test_compare_tuples_1():
    assert (1, 2) == (1, 2)

    if (1, 2) == (1, 2):
        pass
    else:
        assert False

    if (1, 2) != (1, 2):
        assert False

    res = 0

    try:
        assert (1, 2) == (3, 4)
    except AssertionError:
        res = 1

    assert res == 1

@test
def test_compare_tuples_2():
    res = 0

    if (1, 2) is (1, 2):
        assert False

    try:
        assert (1, 2) is (1, 2)
    except AssertionError:
        res = 1

    assert res == 1

    assert (1, 2) is not None

    if (1, 2) is not None:
        pass
    else:
        assert False

@test
def test_compare_tuples_3():
    values: (bool, i64) = None
    res = 0

    try:
        if values == (False, 1):
            pass
    except NoneError:
        res = 1

    assert res == 1

@test
def test_compare_dicts_1():
    assert {1: 2} == {1: 2}

    if {1: 2} == {1: 2}:
        pass
    else:
        assert False

    if {1: 2} != {1: 2}:
        assert False

    res = 0

    try:
        assert {1: 2} == {3: 4}
    except AssertionError:
        res = 1

    assert res == 1

@test
def test_compare_dicts_2():
    res = 0

    if {1: 2} is {1: 2}:
        assert False

    try:
        assert {1: 2} is {1: 2}
    except AssertionError:
        res = 1

    assert res == 1

    assert {1: 2} is not None

    if {1: 2} is not None:
        pass
    else:
        assert False

@test
def test_compare_dicts_3():
    values: {bool: i64} = None
    res = 0

    try:
        if values == {False: 1}:
            pass
    except NoneError:
        res = 1

    assert res == 1

@test
def test_assign_none_to_variable():
    v1 = [1, 2]
    v2 = (1, 2)
    v3 = {1: 2}

    assert v1 is not None
    assert v2 is not None
    assert v3 is not None

    v1 = None
    v2 = None
    v3 = None

    assert v1 is None
    assert v2 is None
    assert v3 is None

@test
def test_add_lists():
    l1 = [1]
    l2 = [2]

    assert l1 + l2 == [1, 2]

    l1 = None
    res = 0

    try:
        if l1 + l2 == [1, 2]:
            pass
    except NoneError:
        res = 1

    assert res == 1

class StringKey:

    a: {string: i64}

@test
def test_string_dict_key_in_class_member():
    assert StringKey({"1": 2}).a == {"1": 2}

@test
def test_tuple_acces_none():
    v: (bool, i32) = None
    res = 0

    try:
        print(v[1])
    except NoneError:
        res = 1

    assert res == 1

@test
def test_dict_acces_none():
    v: {bool: i32} = None
    res = 0

    try:
        print(v[True])
    except NoneError:
        res = 1

    assert res == 1

@test
def test_list_acces_none():
    v: [bool] = None
    res = 0

    try:
        print(v[0])
    except NoneError:
        res = 1

    assert res == 1

def char_foo(v: char) -> char:
    return v

@test
def test_char():
    a = '1'
    b = char(0x31)

    assert a == b
    assert char_foo('5') == '5'
    assert char_foo(a) == a

class MoreTape:
    pass

@trait
class MoreBase:

    def execute(self, tape: MoreTape):
        pass

class MoreFoo(MoreBase):
    x: MoreBase

    def execute(self, tape: MoreTape):
        pass

class MoreBar:
    x: [MoreBase]

    def execute(self, tape: MoreTape):
        pass

@test
def test_more_traits():
    foo = MoreFoo(None)
    bar = MoreBar([foo])

    assert foo.x is None
    assert len(bar.x) == 1

@test
def test_string_get_char():
    a = "cactus"

    assert a[0] == 'c'
    assert a[4] == 'u'
    assert a[5] == 's'

    res = 0

    try:
        print(a[6])
    except IndexError:
        res = 1

    assert res == 1

@test
def test_string_set_char():
    a = "cactus"
    a[0] = 'C'
    a[4] = 'U'
    a[5] = 'S'

    assert a == "CactUS"

    ch = a[3]
    ch = 'x'

    assert a == "CactUS"

    res = 0

    try:
        a[6] = '!'
    except IndexError:
        res = 1

    assert res == 1

@test
def test_string_len_of_none():
    v: string = None
    res = 0

    try:
        print(len(v))
    except NoneError:
        res = 1

    assert res == 1

@test
def test_list_len_of_none():
    v: [u8] = None
    res = 0

    try:
        print(len(v))
    except NoneError:
        res = 1

    assert res == 1

@test
def test_dict_len_of_none():
    v: {u8: string} = None
    res = 0

    try:
        print(len(v))
    except NoneError:
        res = 1

    assert res == 1

@test
def test_string_str_of_none():
    v: string = None
    res = 0

    try:
        print(str(v))
    except NoneError:
        res = 1

    assert res == 1

@test
def test_list_str_of_none():
    v: [u8] = None
    res = 0

    try:
        print(str(v))
    except NoneError:
        res = 1

    assert res == 1

@test
def test_dict_str_of_none():
    v: {u8: string} = None
    res = 0

    try:
        print(str(v))
    except NoneError:
        res = 1

    assert res == 1

@test
def test_char_match_1():
    res = 0
    value = 'a'

    match value:
        case 'a':
            res = 1
        case 'b':
            res = 2

    assert res == 1

@test
def test_char_match_2():
    v = ['a']
    res = 0

    match v[0]:
        case 'a':
            res = 1
        case 'b':
            res = 2

    assert res == 1

@test
def test_u64_literal_match():
    res = 0

    # Should this be allowed?
    match 5:
        case 5:
            res = 1
        case 7:
            res = 2

    assert res == 1

@test
def test_iterate_over_string():
    v: [char] = []
    country = "sweden"

    for ch in country:
        v.append(ch)

    assert v == ['s', 'w', 'e', 'd', 'e', 'n']

@test
def test_add_char_to_string():
    country = "swede"
    country += 'n'

    assert country == "sweden"

@test
def test_unicode_string():
    assert len(str("\u03b1")) == 1
    assert len("\u03b1") == 1
    s = "\u2800\U00010924"
    assert s[0] == '\u2800'
    assert s[1] == '\U00010924'

@test
def test_char_to_string():
    assert str('1') == "1"
    assert '\u03b1' == char(945)
    assert str('\u03b1') == "\u03b1"

@test
def test_bytes():
    v1 = b"\x12\x34\x56"
    v2: bytes = b""

    assert v1 == b"\x12\x34\x56"
    assert v2 == b""
    assert v1 != v2

    if v1 != b"\x12\x34\x56":
        assert False

    if v2 != b"":
        assert False

    if v1 == v2:
        assert False

    assert len(v1) == 3
    assert len(v2) == 0

    v1 += 0x78
    assert v1 == b"\x12\x34\x56\x78"

    # ToDo
    # v1 += b"\x9a"
    # assert v1 == b"\x12\x34\x56\x78\x9a"

    assert v1[0] == 0x12
    assert v1[1] == 0x34
    assert v1[3] == 0x78

    res = 0

    try:
        print(v1[4])
    except IndexError:
        res = 1

    assert res == 1

    v1[0] = 0
    v1[1] += 1
    t = v1[2]
    t = 1
    assert v1 == b"\x00\x35\x56\x78"

@test
def test_tuple_access():
    v = (1, True, "")

    a = v[0]
    a += 1
    assert a == 2
    assert v[0] == 1

    b = v[1]
    b = False
    assert not b
    assert v[1]

@test
def test_for_loop_modify_integer():
    values = [1, 2]

    for value in values:
        value += 1

    assert values == [1, 2]

@test
def test_for_loop_modify_string():
    values = ["1", "2"]

    for value in values:
        value += "1"

    assert values == ["11", "21"]

class ForFoo:
    x: u64

@test
def test_for_loop_modify_class():
    values = [ForFoo(1), ForFoo(2)]

    for value in values:
        value.x += 1

    assert values[0].x == 2
    assert values[1].x == 3

@test
def test_for_loop_slice_modify_integer():
    values = [0, 1, 2, 3, 4]
    sliced: [i64] = []

    for value in slice(values, 1, 3):
        value += 1
        sliced.append(value)

    assert values == [0, 1, 2, 3, 4]
    assert sliced == [2, 3]

@test
def test_string_to_utf8():
    s = "Hello!"
    assert s.to_utf8() == b"Hello!"
    s = "士师」一词，ctext的语译是司法部长。请问有何根"
    assert s.to_utf8() == (
        b"\xe5\xa3\xab\xe5\xb8\x88\xe3\x80\x8d\xe4\xb8\x80\xe8\xaf\x8d\xef"
        b"\xbc\x8c\x63\x74\x65\x78\x74\xe7\x9a\x84\xe8\xaf\xad\xe8\xaf\x91"
        b"\xe6\x98\xaf\xe5\x8f\xb8\xe6\xb3\x95\xe9\x83\xa8\xe9\x95\xbf\xe3"
        b"\x80\x82\xe8\xaf\xb7\xe9\x97\xae\xe6\x9c\x89\xe4\xbd\x95\xe6\xa0"
        b"\xb9")

@test
def test_string_upper():
    s = "Hello!"
    s.upper()
    assert s == "HELLO!"

@test
def test_string_lower():
    s = "Hello!"
    s.lower()
    assert s == "hello!"

class ReturnFoo:

    v: i32

    def bar(self) -> ReturnFoo:
        return ReturnFoo(2 * self.v)

@test
def test_return_foo():
    foo = ReturnFoo(1).bar().bar().bar()

    assert foo.v == 8

@test
def test_value_if_cond_else_value():
    assert (1 if True else 2) == 1

    a = 1
    b = 2
    c = 3

    assert (a if 1 == b else c) == c

@test
def test_string_to_integer():
    assert i32("-12") == -12
    assert u32("12") == 12

@test
def test_string_starts_with():
    s = "hello"

    assert s.starts_with("")
    assert s.starts_with("h")
    assert s.starts_with("hell")
    assert s.starts_with("hello")
    assert not s.starts_with("hello!")
    assert not s.starts_with("e")

def deduce_foo() -> (u16, [i64]):
    return (1, [3, 4])

@test
def test_deduce_compare_types():
    assert u8(1) == 1
    assert -5 != 1
    assert [i8(-1)] == [-1]
    assert (u8(1), 5) == (1, i8(5))
    assert deduce_foo() == (1, [3, 4])
    assert (1.0, [3, 4]) != (1.0, [3, -4, 4, 1])
    assert (1.0, [3, 4]) != (1.0, [3, i8(-4)])
    assert ([(1, True), (i8(5), False)]) == ([(1, True), (5, False)])
    assert [[(1, True)]] != [[(1, True)], [], []]
    assert ([], 5) == ([], 5)
    assert [] == []
    v: [i16] = []
    assert v == []
    assert [[]] == [[]]
    assert [[], []] != [[], [(True, False)]]

@trait
class BaseWithMethodBody:

    def foo(self) -> i64:
        return self.x

class FooWithMethodBody(BaseWithMethodBody):

    x: i64

class BarWithMethodBody(BaseWithMethodBody):

    def foo(self) -> i64:
        return -1

def trait_with_method_body(v: BaseWithMethodBody) -> i64:
    return v.foo()

@test
def test_trait_with_method_body():
    assert trait_with_method_body(FooWithMethodBody(3)) == 3
    assert trait_with_method_body(BarWithMethodBody()) == -1
    assert FooWithMethodBody(2).foo() == 2
    assert BarWithMethodBody().foo() == -1

# ToDo
# class UserError(Error):
#
#     pass
#
# @test
# def test_user_defined_error():
#     res = 0
#
#     try:
#         raise UserError()
#     except UserError:
#         res = 1
#
#     assert res == 1
