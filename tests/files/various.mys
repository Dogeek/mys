# pylint: disable=using-constant-test
# pylint: disable=undefined-variable

def foo() -> int:
    return 5

V1: int = (1 << 2) / 2
V2: int = foo() + 1

def bar(_a: (int, str)):
    "A docstring."

def fie(a: str) -> str:
    return 2 * a

# def calc(callback: Callable[[int, int], int]) -> int:
#     return callback(1, 2)

# def add(a: int, b: int) -> int:
#     return a + b

class Adder:

    def __init__(self):
        self.value: int = 1

#     # Two class methods that creates a new instance from given value.
#     def from_int(value: int) -> Adder:
#         adder: Adder = Adder()
#         adder.value = value
#
#         return adder
#
#     def from_string(value: str) -> Adder:
#         return Adder.from_int(int(value))

    def add(self, a: int, b: int) -> int:
        "Docstring."

        return self.value + a + b

class StaticMethodClass:

    def one_arg(value: int) -> int:
        return 3 * value

    def no_arg() -> int:
        return 5

@test
def test_1():
    # # Text.
    # with open('foo.txt', 'w') as fout:
    #     fout.write('1')
    #
    # with open('foo.txt', 'r') as fin:
    #     assert_eq(fin.read(), '1')
    #
    # # Binary.
    # with open('foo.bin', 'wb') as fout:
    #     fout.write(b'\x01')
    #
    # with open('foo.bin', 'rb') as fin:
    #     assert_eq(fin.read(), b'\x01')

    res: int = 0

    if True:
        res = 1

    assert_eq(res, 1)

    if False:
        res = 2
    else:
        res = 3

    assert_eq(res, 3)

    if False:
        res = 4
    elif False:
        res = 5
    elif True:
        res = 6
    else:
        res = 7

    assert_eq(res, 6)

    try:
        raise TypeError('foo')
    except ValueError:
        res = 8
    except TypeError as e:
        print(e)
        res = 9
    finally:
        assert_eq(res, 9)
        print('finally')
        res = 10

    assert_eq(res, 10)

@test
def test_2():
    res: int = 0
    a: int = 5

    try:
        try:
            for i in range(5):
                print('i, a, i * a:', i, a, i * a)

            raise ValueError()
        except ValueError as e:
            res = 11
            print(e)
            raise

        raise TypeError()
    except ValueError as e:
        assert_eq(res, 11)
        print(e)
        res = 12

    assert_eq(res, 12)

    try:
        raise ValueError()
    except:
        res = 13
        print('Any')

    assert_eq(res, 13)

    try:
        assert False
    except AssertionError as e:
        res = 14
        print(e)

    assert_eq(res, 14)

    assert_eq(V1, 2)
    assert_eq(V2, 6)

    # assert_eq(calc(add), 3)
    adder: Adder = Adder()
    assert_eq(adder.value, 1)
    adder.value += 1
    assert_eq(adder.value, 2)
    assert_eq(str(adder), 'Adder(value=2)')
    # Print a class should work.
    print(adder)
    # assert_eq(calc(adder.add), 5)

@test
def test_3():
    s: str = 'hello'
    print('s:', s, len(s), str(s))
    assert_eq(len(s), 5)
    assert_eq(str(s), s)
    assert_eq(s, 'hello')
    assert_ne(s, 'hello!')
    t: str = s
    assert_eq(s, t)
    t += '!'
    assert_eq(t, 'hello!')
    assert_eq(s, t)
    assert_eq(str(1), '1')
    assert_eq(str(1.0), '1.000000')
    u: int = -5000
    v: str = str(u)
    assert_eq(v, '-5000')
    assert_eq(4 * v, '-5000-5000-5000-5000')
    assert_eq(v * 3, '-5000-5000-5000')
    assert_eq(v + v, '-5000-5000')

    assert_eq(fie(v), '-5000-5000')

@test
def test_4():
    w: [int] = []
    print('w:', w)
    assert_eq(len(w), 0)
    w.append(5)
    w.append(1)
    print('w:', w)
    assert_eq(len(w), 2)
    x: [int] = [5, 1, 5, 1]
    assert_ne(w, x)
    assert_eq(2 * w, x)
    assert_eq(len(2 * w), 4)

    l1: [int] = [1, 2]
    acc: int = 0

    for i in l1:
        acc += i

    assert_eq(acc, 3)

    res: int = 0

    try:
        res = 1
    finally:
        assert_eq(res, 1)
        res = 2

    assert_eq(res, 2)

    '''mys-embedded-c++

    int vv = atoi("2");
    '''

    assert_eq(vv, 2)

    assert_eq(min(-10, 10), -10)
    assert_eq(min(100.1, -200.7), -200.7)
    assert_eq(max(-10, 10), 10)
    assert_eq(max(100.1, -200.7), 100.1)
    mm: int = 10
    nn: int = 15
    assert_eq(min(2 * mm, 21, nn), 15)
    assert_eq(max(2 * mm, 21, nn), 21)
    ll: [int] = [mm, nn]
    assert_eq(min(ll), 10)
    assert_eq(max(ll), 15)
    assert_eq(sum(ll), 25)
    assert_eq(abs(-1), 1)
    assert_eq(abs(5), 5)
    assert_eq(abs(-1.5), 1.5)

    assert_eq(len(range(-2, 10)), 12)
    assert_eq(min(range(-2, 10)), -2)
    assert_eq(max(range(-2, 10)), 9)
    assert_eq(sum(range(-2, 10)), 42)

    s1: str = '''a\t
    multi
    line
    string\n'''
    s2: str = 'a\t\n    multi\n    line\n    string\n'
    assert_eq(s1, s2)

@test
def test_fstring():
    v: str = f''
    assert_eq(v, '')
    v = f'foo'
    assert_eq(v, 'foo')
    assert_eq(f'c{1+1}s', 'c2s')
    assert_eq(f'{2 * v}', 'foofoo')

@test
def test_list():
    v: [int] = [3, 2, 1]
    assert_eq(v[0], 3)
    assert_eq(v[1], 2)
    assert_eq(v[2], 1)

    res: int = 0

    try:
        assert_eq(v[3], 1)
    except:
        res = 1

    assert_eq(res, 1)

@test
def test_assert_eq():
    value: bool = False

    assert_eq(1, 1)

    try:
        assert_eq(0, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_ne():
    value: bool = False
    assert_ne(0, 1)

    try:
        assert_ne(1, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_gt():
    value: bool = False
    assert_gt(1, 0)

    try:
        assert_gt(1, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_ge():
    value: bool = False
    assert_ge(1, 0)
    assert_ge(1, 1)

    try:
        assert_ge(1, 2)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_lt():
    value: bool = False
    assert_lt(0, 1)

    try:
        assert_lt(1, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_le():
    value: bool = False
    assert_le(0, 1)
    assert_le(1, 1)

    try:
        assert_le(2, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_in():
    value: bool = False
    values: [int] = [1, 2, 4]
    assert_in(1, values)
    assert_in(2, values)
    assert_in(4, values)

    try:
        assert_in(3, values)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_not_in():
    value: bool = False
    values: [int] = [1, 2, 4]
    assert_not_in(0, values)
    assert_not_in(3, values)
    assert_not_in(5, values)

    try:
        assert_not_in(1, values)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_true():
    value: bool = False
    assert_true(True)

    try:
        assert_true(False)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_false():
    value: bool = False
    assert_false(False)

    try:
        assert_false(True)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_and_or():
    assert_false(True and False)
    assert_true(True or False)

@test
def test_not():
    assert_true(not False)
    assert_false(not (False or True))

@test
def test_boolean_logic():
    assert_false(True and (not False) and False)
    assert_false(True and not False and False)

# @test
# def test_class():
#     adder1: Adder = Adder.from_int(5)
#     assert_eq(adder.value, 5)
#     adder2: Adder = Adder.from_string('6')
#     assert_eq(adder.value, 6)
