# pylint: disable=using-constant-test
# pylint: disable=undefined-variable

def foo() -> i32:
    return 5

V1: i32 = (1 << 2) / 2
V2: i32 = foo() + 1

def bar(_a: (i32, string)):
    "A docstring."

def fie(a: string) -> string:
    return 2 * a

class Adder:

    value: i32 = 1
    base: i32

    def add(self, a: i32, b: i32) -> i32:
        "Docstring."

        return self.base + self.value + a + b

def calc(adder: Adder) -> u32:
    return adder.add(1, 4)

class OperatorOverloading:

    def __eq__(self, other: OperatorOverloading) -> bool:
        return True

    def __ne__(self, other: OperatorOverloading) -> bool:
        return True

    def __gt__(self, other: OperatorOverloading) -> bool:
        return True

    def __ge__(self, other: OperatorOverloading) -> bool:
        return True

    def __lt__(self, other: OperatorOverloading) -> bool:
        return True

    def __le__(self, other: OperatorOverloading) -> bool:
        return True

    def __iadd__(self, other: OperatorOverloading):
        pass

    def __isub__(self, other: OperatorOverloading):
        pass

@test
def test_1():
    # # Text.
    # with open("foo.txt", "w") as fout:
    #     fout.write("1")
    #
    # with open("foo.txt", "r") as fin:
    #     assert_eq(fin.read(), "1")
    #
    # # Binary.
    # with open("foo.bin", "wb") as fout:
    #     fout.write(b"\x01")
    #
    # with open("foo.bin", "rb") as fin:
    #     assert_eq(fin.read(), b"\x01")

    res = 0

    if True:
        res = 1

    assert_eq(res, 1)

    if False:
        res = 2
    else:
        res = 3

    assert_eq(res, 3)

    if False:
        res = 4
    elif False:
        res = 5
    elif True:
        res = 6
    else:
        res = 7

    assert_eq(res, 6)

    try:
        raise TypeError("foo")
    except ValueError:
        res = 8
    except TypeError as e:
        print(e)
        res = 9
    finally:
        assert_eq(res, 9)
        print("finally")
        res = 10

    assert_eq(res, 10)

@test
def test_2():
    res = 0
    a = 5

    try:
        try:
            for i in range(5):
                print("i, a, i * a:", i, a, i * a)

            raise ValueError()
        except ValueError as e:
            res = 11
            print(e)
            raise

        raise TypeError()
    except ValueError as e:
        assert_eq(res, 11)
        print(e)
        res = 12

    assert_eq(res, 12)

    try:
        raise ValueError()
    except:
        res = 13
        print("Any")

    assert_eq(res, 13)

    try:
        assert False
    except AssertionError as e:
        res = 14
        print(e)

    assert_eq(res, 14)

    assert_eq(V1, 2)
    assert_eq(V2, 6)

    adder = Adder(1, 0)
    assert_eq(adder.base, 0)
    assert_eq(adder.value, 1)
    adder.value += 1
    assert_eq(adder.value, 2)
    # ToDo: Uncomment.
    # assert_eq(str(adder), "Adder(value=2, base=0)")
    # Print a class should work.
    print(adder)
    assert_eq(calc(adder), 7)

@test
def test_3():
    s = "hello"
    print("s:", s, len(s), str(s))
    assert_eq(len(s), 5)
    assert_eq(str(s), s)
    assert_eq(s, "hello")
    assert_ne(s, "hello!")
    t = s
    assert_eq(s, t)
    t += "!"
    assert_eq(t, "hello!")
    assert_eq(s, t)
    assert_eq(str(1), "1")
    assert_eq(str(1.0), "1.000000")
    u = -5000
    v = str(u)
    assert_eq(v, "-5000")
    assert_eq(4 * v, "-5000-5000-5000-5000")
    assert_eq(v * 3, "-5000-5000-5000")
    assert_eq(v + v, "-5000-5000")

    assert_eq(fie(v), "-5000-5000")

# ToDo: Uncomment.
# @test
# def test_4():
#     w: [i32] = []
#     print("w:", w)
#     assert_eq(len(w), 0)
#     w.append(5)
#     w.append(1)
#     print("w:", w)
#     assert_eq(len(w), 2)
#     x: [i32] = [5, 1, 5, 1]
#     assert_ne(w, x)
#     assert_eq(2 * w, x)
#     assert_eq(len(2 * w), 4)
#
#     l1: [i32] = [1, 2]
#     acc = 0
#
#     for i in l1:
#         acc += i
#
#     assert_eq(acc, 3)
#
#     res = 0
#
#     try:
#         res = 1
#     finally:
#         assert_eq(res, 1)
#         res = 2
#
#     assert_eq(res, 2)
#     vv = 0
#
#     """mys-embedded-c++
#
#     vv = atoi("2");
#     """
#
#     assert_eq(vv, 2)
#
#     assert_eq(min(-10, 10), -10)
#     assert_eq(min(100.1, -200.7), -200.7)
#     assert_eq(max(-10, 10), 10)
#     assert_eq(max(100.1, -200.7), 100.1)
#     mm: i32 = 10
#     nn: i32 = 15
#     assert_eq(min(2 * mm, 21, nn), 15)
#     assert_eq(max(2 * mm, 21, nn), 21)
#     ll: [i32] = [mm, nn]
#     assert_eq(min(ll), 10)
#     assert_eq(max(ll), 15)
#     assert_eq(sum(ll), 25)
#     assert_eq(abs(-1), 1)
#     assert_eq(abs(5), 5)
#     assert_eq(abs(-1.5), 1.5)
#
#     assert_eq(len(range(-2, 10)), 12)
#     assert_eq(min(range(-2, 10)), -2)
#     assert_eq(max(range(-2, 10)), 9)
#     assert_eq(sum(range(-2, 10)), 42)
#
#     s1 = """a\t
#     multi
#     line
#     string\n"""
#     s2 = "a\t\n    multi\n    line\n    string\n"
#     assert_eq(s1, s2)

@test
def test_fstring():
    v: string = f""
    assert_eq(v, "")
    v = f"foo"
    assert_eq(v, "foo")
    assert_eq(f"c{1+1}s", "c2s")
    assert_eq(f"{2 * v}", "foofoo")

@test
def test_list():
    v: [i32] = [3, 2, 1]
    assert_eq(v[0], 3)
    assert_eq(v[1], 2)
    assert_eq(v[2], 1)

    res = 0

    try:
        assert_eq(v[3], 1)
    except:
        res = 1

    assert_eq(res, 1)

@test
def test_assert_eq():
    value = False

    assert_eq(1, 1)

    try:
        assert_eq(0, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_ne():
    value = False
    assert_ne(0, 1)

    try:
        assert_ne(1, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_gt():
    value = False
    assert_gt(1, 0)

    try:
        assert_gt(1, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_ge():
    value = False
    assert_ge(1, 0)
    assert_ge(1, 1)

    try:
        assert_ge(1, 2)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_lt():
    value = False
    assert_lt(0, 1)

    try:
        assert_lt(1, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_le():
    value = False
    assert_le(0, 1)
    assert_le(1, 1)

    try:
        assert_le(2, 1)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_in():
    value = False
    values: [i32] = [1, 2, 4]
    assert_in(1, values)
    assert_in(2, values)
    assert_in(4, values)

    try:
        assert_in(3, values)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_not_in():
    value = False
    values: [i32] = [1, 2, 4]
    assert_not_in(0, values)
    assert_not_in(3, values)
    assert_not_in(5, values)

    try:
        assert_not_in(1, values)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_true():
    value = False
    assert_true(True)

    try:
        assert_true(False)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_assert_false():
    value = False
    assert_false(False)

    try:
        assert_false(True)
    except AssertionError:
        value = True

    assert_true(value)

@test
def test_and_or():
    assert_false(True and False)
    assert_true(True or False)

@test
def test_not():
    assert_true(not False)
    assert_false(not (False or True))

@test
def test_boolean_logic():
    assert_false(True and (not False) and False)
    assert_false(True and not False and False)
    assert_true(True and (not False) or False)
    assert_true((True and (not False)) or False)
    assert_true(True and ((not False) or False))

@test
def test_print():
    print("Hi!")
    print("Hi!", end="!!\n")
    print("Hi!", flush=True)

def default_1(a: i32 = 3) -> i32:
    return a

def default_2(a: i32 = 3, b: i32 = 2) -> i32:
    return a + b

def default_3(a: i32, b: i32 = 2) -> i32:
    return a + b

def default_4(a: i32, b: i32 = 2) -> i32:
    return a + b

@test
def test_default_params():
    assert_eq(default_1(), 3)
    assert_eq(default_1(1), 1)
    assert_eq(default_2(), 5)
    assert_eq(default_2(1), 3)
    assert_eq(default_2(1, 0), 1)
    # assert_eq(default_2(b=1), 4)
    # assert_eq(default_2(b=1, a=0), 1)
    # assert_eq(default_2(1, b=3), 4)
    assert_eq(default_3(1), 3)
    assert_eq(default_3(1, 0), 1)
    # assert_eq(default_3(1, b=0), 1)
    # assert_eq(default_3(a=1, b=0), 1)
    # assert_eq(default_3(b=1, a=0), 1)

@test
def test_match_integer_1():
    value = 0
    res = 0

    match value:
        case 0:
            res = 1
        case _:
            res = 2

    assert_eq(res, 1)

@test
def test_match_integer_2():
    value = 1

    match value:
        case 1:
            value = 3

    assert_eq(value, 3)

@test
def test_match_string():
    value = "hi"
    res = 0

    match value:
        case "123":
            res = 5
        case "hi":
            res = 6
        case _:
            res = 7

    assert_eq(res, 6)

ONLY_ONCE_VALUE: i32 = 0

def only_once(value: i32) -> i32:
    ONLY_ONCE_VALUE += 1

    return value

@test
def test_match_function_once():
    value = 0
    ONLY_ONCE_VALUE = 0

    match only_once(1):
        case 0:
            value = 1
        case 1:
            value = 2

    assert_eq(value, 2)
    assert_eq(ONLY_ONCE_VALUE, 1)

@trait
class MatchBase:
    pass

class MatchFoo(MatchBase):
    pass

class MatchBar(MatchBase):
    pass

class MatchFie(MatchBase):
    pass

def foo_trait(base: MatchBase) -> i32:
    result = 0

    match base:
        case MatchFoo():
            result = 1
        case MatchBar() as value:
            result = 2
        case MatchFie() as value:
            result = 3

    return result

@test
def test_match_trait():
    assert_eq(foo_trait(MatchFoo()), 1)
    assert_eq(foo_trait(MatchBar()), 2)
    assert_eq(foo_trait(MatchFie()), 3)

@test
def test_try_except_else():
    res = 0

    try:
        value = True
    except ValueError:
        res = 1
    else:
        # ToDo: 'value' is available
        # assert_true(value)
        res = 2

    assert_eq(res, 2)

@test
def test_try_except_else_finally():
    """Same as previous test, but with finally.

    """

    res = 0

    try:
        value = True
    except ValueError:
        res = 1
    else:
        # ToDo: 'value' is available
        # assert_true(value)
        res = 2
    finally:
        res = 3

    assert_eq(res, 3)

@trait
class Base:

    def bar(self, value: i32) -> bool:
        pass

@trait
class Base2:

    def fie(self):
        pass

class Foo(Base):

    def bar(self, value: i32) -> bool:
        return True

class Bar(Base, Base2):

    def bar(self, value: i32) -> bool:
        return False

    def fie(self):
        print()

def trait_call(base: Base) -> bool:
    return base.bar(1)

@test
def test_implement_trait_in_class():
    foo = Foo()
    bar = Bar()
    assert_true(foo.bar(1))
    assert_false(bar.bar(1))
    assert_true(trait_call(Foo()))
    assert_false(trait_call(Bar()))
    bar.fie()

class InferredFoo:

    a: i32

def inferred_foo() -> i32:
    return -3

@test
def test_inferred_types_in_assignments():
    value_1 = 1
    value_2 = -1
    value_3 = +1
    value_4 = "a"
    value_5 = True
    value_6 = 6.44
    value_7 = -6.44
    value_8 = InferredFoo(5)
    value_9 = inferred_foo()
    value_10 = InferredFoo(4).a

    assert_eq(value_1, 1)
    assert_eq(value_2, -1)
    assert_eq(value_3, 1)
    assert_eq(value_4, "a")
    assert_eq(value_5, True)
    assert_eq(value_6, 6.44)
    assert_eq(value_7, -6.44)
    assert_eq(value_8.a, 5)
    assert_eq(value_9, -3)
    assert_eq(value_10, 4)

@test
def test_not_inferred_types_in_assignments():
    value_1: i32 = 1
    value_2: i32 = -1
    value_3: i32 = +1
    value_4: string = "a"
    value_5: bool = True
    value_6: f64 = 6.44
    value_7: f64 = -6.44
    value_8: InferredFoo = InferredFoo(5)
    value_9: i32 = inferred_foo()
    value_10: i32 = InferredFoo(4).a

    assert_eq(value_1, 1)
    assert_eq(value_2, -1)
    assert_eq(value_3, 1)
    assert_eq(value_4, "a")
    assert_eq(value_5, True)
    assert_eq(value_6, 6.44)
    assert_eq(value_7, -6.44)
    assert_eq(value_8.a, 5)
    assert_eq(value_9, -3)
    assert_eq(value_10, 4)

def string_foo(value: string) -> string:
    # ToDo:
    # value += " Mouse"

    return value

@test
def test_string_as_function_parameter():
    assert_eq(string_foo("Cat"), "Cat")

@enum
class City:

    Linkoping = 5
    Norrkoping = 8
    Vaxjo = 10

@test
def test_enum_if_else():
    value = City.Linkoping
    res = 0

    if value == City.Linkoping:
        res = 1
    elif value == City.Norrkoping:
        res = 2

    assert_eq(res, 1)

@test
def test_enum_assignment():
    value_1: City = City.Linkoping
    value_2 = City.Vaxjo

    assert_eq(value_1, City.Linkoping)
    assert_eq(value_2, City.Vaxjo)

def enum_foo(source: City, destination: City) -> City:
    return City.Vaxjo

@test
def test_enum_as_function_parameter_and_return_value():
    value = City.Linkoping

    assert_eq(enum_foo(value, City.Norrkoping), City.Vaxjo)

class FooGlob:
    value: i32

def glob_foo(v: i32) -> i32:
    return 2 * v

def glob_bar(v: FooGlob) -> i32:
    return 3 * v.value

GLOB_1: i32 = 1
GLOB_2: string = ""
GLOB_3: FooGlob = FooGlob(5)
GLOB_4: i32 = glob_foo(1)
GLOB_5: i32 = glob_foo(glob_foo(-1))
GLOB_6: i32 = glob_foo(glob_bar(FooGlob(5)))
GLOB_7: i32 = GLOB_1

@test
def test_global_variable():
    assert_eq(GLOB_1, 1)
    assert_eq(GLOB_2, "")
    assert_eq(GLOB_3.value, 5)
    assert_eq(GLOB_4, 2)
    assert_eq(GLOB_5, -4)
    assert_eq(GLOB_6, 30)
    assert_eq(GLOB_7, 1)

@test
def test_explicit_integer_type_convertions():
    v1: u8 = 0xff
    v2: i16 = -5

    assert_true(v1 == u8(0x1ff))
    assert_true(v2 == i16(-5))
    assert_true(i32(i16(-1)) == i32(-1))
    assert_true(u8(v2) == u8(0xfb))

@test
def test_integer_constants():
    v1 = 0x7fffffffffffffff
    v2: i64 = 0x7fffffffffffffff
    v3: i8 = 0x7f
    v4: i8 = -0x80
    v5: u8 = 0
    v6: u8 = 0xff
    v7: u64 = 0xffffffffffffffff

    assert_eq(v1, v2)
    assert_eq(v3 - 127 - 127 - 1, v4)
    assert_eq(v5 + 255, v6)
    # assert_true(v7 == 0xffffffffffffffff)

@test
def test_change_integer_type():
    v1 = i8(-1) * i8(u32(5))

    assert_eq(v1, -5)
