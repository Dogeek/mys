def context_manager():
    path = "src/main.mys"

    with open(path) as fin:
        print(f"{path} is {fin.read().length()} bytes")

    print(f"fin after with: {fin}")

def all_branches(argc: i64):
    if argc == 1:
        value = -1
    elif argc == 2:
        value = -2
    else:
        raise Error()

    print(f"value: {value}")

def change_type():
    value = "a string"
    assert_eq(value, "a string")

    # Make 'value' an integer instead of a string.
    value = 5
    assert_eq(value, 5)

def inconclusive(argc: i64):
    if argc == 1:
        value = ""
        assert_eq(value, "")
    else:
        value = True
        assert_true(value)

    # 'value' can't be used here as it's type is inconclusive (it's
    # either a string or a bool). It can be defined though.
    value = 9
    assert_eq(value, 9)

def inconclusive_2(argc: i64):
    value = ""

    if argc == 1:
        assert_eq(value, "")
    else:
        value = True
        assert_true(value)

    # 'value' can't be used here as it's type is inconclusive (it's
    # either a string or a bool). It can be defined though.
    value = 9
    assert_eq(value, 9)

def for_loops():
    values: [string] = []

    for value in values:
        pass

    assert_eq(value, None)

    for value in [False, True]:
        pass

    assert_true(value)

    for value in [1, -1]:
        pass

    assert_eq(value, -1)

def try_except():
    try:
        value = 1
    except:
        value = 2

    assert_eq(value, 1)

def try_else():
    try:
        value = 1
    except:
        pass
    else:
        assert_eq(value, 1)

def try_except_finally():
    try:
        value = 1

        raise Error()
    except Error:
        assert_eq(value, 1)
    finally:
        assert_eq(value, 1)

def main(argv: [string]):
    argc = argv.length()

    context_manager()
    all_branches(argc)
    change_type()
    inconclusive(argc)
    inconclusive_2(argc)
    for_loops()
    try_except()
    try_else()
    try_except_finally()
