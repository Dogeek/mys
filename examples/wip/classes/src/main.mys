class InventoryItem:
    """An inventory item.

    """

    name: string
    "Its name."

    quantity: u32
    """Its quantity.

    Must be greater or equal to zero.

    """

    # Automatically added if not user defined:

    def __init__(self, name: string = None, quantity: u32 = 0):
        self.name = name
        self.quantity = quantity

    def __str__(self):
        return f"InventoryItem(name={self.name}, quantity={self.quantity})"

class Rectangle:
    """A rectangle.

    """

    _name: string
    width: u32
    height: u32

    def area(self) -> u32:
        """Returns the area of the rectangle.

        """

        return self.width * self.height

    # Automatically added if not user defined:

    def __init__(self, self._name = None, width: u32 = 0, height: u32 = 0):
        self._name = name
        self.width = width
        self.height = height

    def __str__(self):
        return f"Rectangle(width={self.width}, height={self.height})"

class Square(Rectangle):

    def __init__(self, side: u32):
        super(Rectangle).__init__(None, side, side)

    # Automatically added if not user defined:

    def __init__(self):
        super(Rectangle).__init__()

    def __str__(self):
        return f"Square() : {super(Rectangle).__str__()}"

def calc_default_bar():
    return 0

class Fie:

    a: i32
    b: string

class Fam:

    bar: Bar

class Goo:
    pass

_FAM = Fam()

class Bar(Goo):

    foo: i64
    bar: i32 = calc_default_bar()
    fie: Fie = Fie(1, b="Hello!")
    fam1: Fam = _FAM
    fam2: Fam

    # Automatically added if not user defined:

    def __init__(self,
                 foo: int = 0,
                 bar: int = calc_default_bar(),
                 fie: Fie = Fie(1, b="Hello!"),
                 fam1: Fam = _FAM,
                 fam2: Fam = None):
        self.foo = foo
        self.bar = bar
        self.fie = fie
        self.fam1 = fam1
        self.fam2 = fam2
        super(Goo).__init__()

class A:

    def area(self) -> u32:
        return self.length() ** 2

    def length(self) -> u32:
        return 2

class B(A):

    @override
    def length(self) -> u32:
        return 3

class Cow:

    _data: bytes

    def to_bytes(self) -> bytes:
        return self._data

    # "static" methods do not operate on self. Same as any function
    # except that it is defined in the class namespace.
    def from_bytes(data: bytes) -> Cow:
        return Cow(data)

def main():
    apples = InventoryItem("Apples", 1.3)
    print(apples)

    a = A()
    assert_eq(a.length(), 2)
    assert_eq(a.area(), 4)

    b = B()
    assert_eq(b.length(), 3)
    # Also 4 as length() is not overridden, just redefined.
    assert_eq(b.area(), 4)

    cow_1 = Cow(b"1234")
    data = cow_1.to_bytes()
    cow_2 = Cow.from_bytes(data)
    assert_true(cow_1 == cow_2)
    assert_false(cow_1 is cow_2)
